namespace Perf.Holders.Generator.Builders;

using System.Buffers;
using Internal;
using Types;

sealed class MultiResultSystemTextJsonSourceBuilder(MultiResultHolderContextInfo context) {
    const string Exceptions = "global::Perf.Holders.Exceptions.MultiResultHolderExceptions";
    readonly InterpolatedStringBuilder sb = new(stringBuilder: new(8000));

    readonly CompInfo compInfo = context.CompInfo;
    int bracesToCloseOnEnd;

    void Preparation() {
        if (compInfo.SupportNullableAnnotation() is false) {
            var els = context.Elements;
            for (var i = 0; i < els.Count; i++) {
                var el = els[i];
                if (el.IsStruct is false) {
                    els[i] = el with {
                        TypeNullable = el.Type
                    };
                }
            }

            // no need to update Elements within context, EquatableList holds elements in common List
        }
    }

    public string WriteAllAndBuild() {
        Preparation();
        DeclareTopLevelStatements();
        if (context.MultiResult.TypeParameterCount > 0) {
            WriteJsonConverterFactory();
        }

        WriteJsonConverter();
        WriteEndOfFile();
        return sb.ToString();
    }

    void DeclareTopLevelStatements() {
        sb.AppendLine("// <auto-generated />");
        if (compInfo.SupportNullableAnnotation()) {
            sb.AppendLine("#nullable enable");
        }

        if (compInfo.SupportFileScopedNamespace()) {
            sb.AppendLine("namespace Perf.Holders.Serialization.SystemTextJson;");
        } else {
            sb.AppendLine("namespace Perf.Holders.Serialization.SystemTextJson\n{");
            bracesToCloseOnEnd++;
        }
    }

    void WriteJsonConverterFactory() {
        var accessibility = context.GlobalAccessibility is TypeAccessibility.Public ? "public " : "";
        const string stj = "global::System.Text.Json";
        const string stjSer = "global::System.Text.Json.Serialization";
        var openTypeParameters = context.OpenTypeParameters();

        var globalNameString = context.MultiResult.GlobalName;
        var globalNameBuffer = ArrayPool<char>.Shared.Rent(globalNameString.Length);
        var globalName = globalNameBuffer.AsSpan(0, globalNameString.Length);
        globalNameString.AsSpan().CopyTo(globalName);
        var indexStart = globalName.LastIndexOf('<');
        openTypeParameters.AsSpan().CopyTo(globalName[indexStart..]);
        globalName = globalName[..(indexStart + openTypeParameters.Length)];

        sb.AppendInterpolatedLine(
            $$"""
            {{accessibility}}sealed class JsonConverterFactory_{{context.MultiResult.OnlyName}} : {{stjSer}}.JsonConverterFactory
            {
                public static readonly JsonConverterFactory_{{context.MultiResult.OnlyName}} Instance = new();
                
                public override bool CanConvert(Type typeToConvert) =>
                    cache.ContainsKey(typeToConvert) || (typeToConvert.IsConstructedGenericType && typeToConvert.GetGenericTypeDefinition() == typeof({{globalName}}));

                private readonly global::System.Collections.Concurrent.ConcurrentDictionary<Type, {{stjSer}}.JsonConverter> cache = new();
                
                public override {{stjSer}}.JsonConverter CreateConverter(Type typeToConvert, {{stj}}.JsonSerializerOptions options) =>
                    cache.GetOrAdd(
                        typeToConvert,
                        static t => {
                            var genericArguments = t.GetGenericArguments();
                            var t1 = genericArguments[0];
                            var t2 = genericArguments[1];
                            return ({{stjSer}}.JsonConverter)global::System.Activator.CreateInstance(typeof(JsonConverter_{{context.MultiResult.OnlyName}}{{openTypeParameters}}).MakeGenericType(genericArguments))!;
                        }
                    ); 
            }
            """
        );

        ArrayPool<char>.Shared.Return(globalNameBuffer);
    }

    void WriteJsonConverter() {
        var accessibility = context.GlobalAccessibility is TypeAccessibility.Public ? "public " : "";
        const string stj = "global::System.Text.Json";
        const string stjSer = "global::System.Text.Json.Serialization";
        var typeParametersConstraints = context.MultiResult.TypeParameterCount > 0 ? $"    {context.TypeParametersConstraints(' ')} " : "";

        sb.AppendInterpolatedLine(
            $$"""
            [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]
            {{accessibility}}sealed class JsonConverter_{{context.MultiResult.DeclarationName}} : {{stjSer}}.JsonConverter<{{context.MultiResult.GlobalName}}>
            {{typeParametersConstraints}}{
                public static readonly JsonConverter_{{context.MultiResult.DeclarationName}} Instance = new();
            """
        );
        sb.Indent++;
        sb.AppendInterpolatedLine(
            $"public override void Write({stj}.Utf8JsonWriter writer, {context.MultiResult.GlobalName} value, {stj}.JsonSerializerOptions options)"
        );
        sb.AppendLine("{");
        sb.Indent++;
        sb.AppendLine("writer.WriteStartObject();");
        sb.Indent++;

        if (context.Configuration.OpenState is true) {
            sb.AppendLine("var state = (byte)value.State;");
        } else if (context.Configuration.AddIsProperties is true) {
            sb.Append("byte state = ");
            foreach (var el in context.Elements) {
                sb.AppendInterpolated($"value.{el.StateCheck.Property} ? (byte){el.Index + 1} : ");
            }

            sb.AppendLine("(byte)0;");
        }

        sb.AppendLine("switch(state) {");
        sb.Indent++;
        foreach (var el in context.Elements) {
            sb.AppendInterpolatedLine($"case {el.Index + 1}:");
            sb.Indent++;
            sb.AppendInterpolatedLine($"writer.WritePropertyName({MultiResultHolderContextInfo.MultiResultElementInfo.Fields[el.Index]}Bytes);");
            sb.AppendInterpolatedLine($"{stj}.JsonSerializer.Serialize(writer, value.{el.Property}, options);");
            sb.Indent--;
            sb.AppendLine("break;");
        }

        sb.AppendInterpolatedLine($"default: throw {Exceptions}.Default<{context.MultiResult.GlobalName}>();");
        sb.Indent--;
        sb.AppendLine("}");
        sb.AppendLine("writer.WriteEndObject();");
        //
        sb.Indent--;
        sb.AppendLine("}");
        sb.AppendInterpolatedLine(
            $"public override {context.MultiResult.GlobalName} Read(ref {stj}.Utf8JsonReader reader, global::System.Type typeToConvert, {stj}.JsonSerializerOptions options)"
        );
        sb.AppendLine("{");
        sb.Indent++;
        sb.AppendInterpolatedLine(
            $$"""
            if (reader.TokenType != {{stj}}.JsonTokenType.StartObject) throw new {{stj}}.JsonException($"Expected '{({{stj}}.JsonTokenType.StartObject)}' but got '{reader.TokenType}'");
            reader.Read();
            var span = reader.ValueSpan;
            """
        );
        foreach (var el in context.Elements) {
            sb.AppendInterpolatedLine(
                $$"""
                if (span.SequenceEqual({{MultiResultHolderContextInfo.MultiResultElementInfo.Fields[el.Index]}}Bytes)) {
                    var value = {{stj}}.JsonSerializer.Deserialize<{{el.Type}}>(ref reader, options)!;
                    reader.Read();
                    return value;
                }
                """
            );
        }

        sb.AppendInterpolatedLine($$"""throw new {{stj}}.JsonException("Expected MultiResult ordinal field name property");""");

        sb.Indent--;
        sb.AppendLine("}");

        sb.AppendLine("#region Property names");

        foreach (var el in context.Elements) {
            var fieldDefaultString = MultiResultHolderContextInfo.MultiResultElementInfo.Fields[el.Index];
            sb.Append($"public static readonly byte[] {fieldDefaultString}Bytes = new byte[] {{");
            foreach (var c in fieldDefaultString) {
                sb.Append($"{(byte)c},");
            }

            sb.Length--;
            sb.AppendLine("};");
        }

        sb.AppendLine("#endregion");

        sb.Indent--;
        sb.AppendLine("}");
    }

    void WriteEndOfType() {
        sb.Indent--;
        bracesToCloseOnEnd--;
        sb.AppendLine("}");
    }

    void WriteEndOfFile() {
        for (var i = 0; i < bracesToCloseOnEnd; i++) {
            sb.Append('}');
        }

        sb.AppendLine();
    }
}
