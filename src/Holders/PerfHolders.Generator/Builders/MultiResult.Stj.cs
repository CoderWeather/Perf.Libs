namespace Perf.Holders.Generator.Builders;

using Internal;
using Types;

sealed class MultiResultSystemTextJsonSourceBuilder(MultiResultHolderContextInfo context) {
    const string Exceptions = "global::Perf.Holders.Exceptions.MultiResultHolderExceptions";
    readonly InterpolatedStringBuilder sb = new(stringBuilder: new(8000));

    readonly CompInfo compInfo = context.CompInfo;
    int bracesToCloseOnEnd;

    void Preparation() {
        if (compInfo.SupportNullableAnnotation() is false) {
            var els = context.Elements;
            for (var i = 0; i < els.Count; i++) {
                var el = els[i];
                if (el.IsStruct is false) {
                    els[i] = el with {
                        TypeNullable = el.Type
                    };
                }
            }

            // no need to update Elements within context, EquatableList holds elements in common List
        }
    }

    public string WriteAllAndBuild() {
        Preparation();
        DeclareTopLevelStatements();
        WriteJsonConverter();
        // WriteEndOfType();
        WriteEndOfFile();
        return sb.ToString();
    }

    void DeclareTopLevelStatements() {
        sb.AppendLine("// <auto-generated />");
        if (compInfo.SupportNullableAnnotation()) {
            sb.AppendLine("#nullable enable");
        }

        if (compInfo.SupportFileScopedNamespace()) {
            sb.AppendLine("namespace Perf.Holders.Serialization.SystemTextJson;");
        } else {
            sb.AppendLine("namespace Perf.Holders.Serialization.SystemTextJson\n{");
            bracesToCloseOnEnd++;
        }
    }

    void WriteJsonConverter() {
        if (context.MultiResult.TypeParameterCount > 0) {
            return;
        }

        var accessibility = context.MultiResult.Accessibility is TypeAccessibility.Public ? "public " : "";
        const string stj = "global::System.Text.Json";
        const string stjSer = "global::System.Text.Json.Serialization";
        sb.AppendInterpolatedLine(
            $$"""
            [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]
            {{accessibility}}sealed class JsonConverter_{{context.MultiResult.OnlyName}} : {{stjSer}}.JsonConverter<{{context.MultiResult.GlobalName}}>
            {
                public static readonly JsonConverter_{{context.MultiResult.OnlyName}} Instance = new();
            """
        );
        sb.Indent++;
        sb.AppendInterpolatedLine(
            $"public override void Write({stj}.Utf8JsonWriter writer, {context.MultiResult.GlobalName} value, {stj}.JsonSerializerOptions options)"
        );
        sb.AppendLine("{");
        sb.Indent++;
        sb.AppendLine("writer.WriteStartObject();");
        sb.Indent++;

        if (context.Configuration.OpenState is true) {
            sb.AppendLine("var state = (byte)value.State;");
        } else if (context.Configuration.AddIsProperties is true) {
            sb.Append("byte state = ");
            foreach (var el in context.Elements) {
                sb.AppendInterpolated($"value.{el.StateCheck.Property} ? (byte){el.Index + 1} : ");
            }

            sb.AppendLine("(byte)0;");
        }

        sb.AppendLine("switch(state) {");
        sb.Indent++;
        foreach (var el in context.Elements) {
            sb.AppendInterpolatedLine($"case {el.Index + 1}:");
            sb.Indent++;
            sb.AppendInterpolatedLine($"writer.WritePropertyName({MultiResultHolderContextInfo.MultiResultElementInfo.Fields[el.Index]}Bytes);");
            sb.AppendInterpolatedLine($"{stj}.JsonSerializer.Serialize(writer, value.{el.Property}, options);");
            sb.Indent--;
            sb.AppendLine("break;");
        }

        sb.AppendInterpolatedLine($"default: throw {Exceptions}.Default<{context.MultiResult.GlobalName}>();");
        sb.Indent--;
        sb.AppendLine("}");
        sb.AppendLine("writer.WriteEndObject();");
        //
        sb.Indent--;
        sb.AppendLine("}");
        sb.AppendInterpolatedLine(
            $"public override {context.MultiResult.GlobalName} Read(ref {stj}.Utf8JsonReader reader, global::System.Type typeToConvert, {stj}.JsonSerializerOptions options)"
        );
        sb.AppendLine("{");
        sb.Indent++;
        sb.AppendInterpolatedLine(
            $$"""
            if (reader.TokenType != {{stj}}.JsonTokenType.StartObject) throw new {{stj}}.JsonException($"Expected '{({{stj}}.JsonTokenType.StartObject)}' but got '{reader.TokenType}'");
            reader.Read();
            var span = reader.ValueSpan;
            """
        );
        foreach (var el in context.Elements) {
            sb.AppendInterpolatedLine(
                $$"""
                if (span.SequenceEqual({{MultiResultHolderContextInfo.MultiResultElementInfo.Fields[el.Index]}}Bytes)) {
                    var value = {{stj}}.JsonSerializer.Deserialize<{{el.Type}}>(ref reader, options)!;
                    reader.Read();
                    return value;
                }
                """
            );
        }

        sb.AppendInterpolatedLine($$"""throw new {{stj}}.JsonException("Expected MultiResult ordinal field name property");""");

        sb.Indent--;
        sb.AppendLine("}");

        sb.AppendLine("#region Property names");

        foreach (var el in context.Elements) {
            var fieldDefaultString = MultiResultHolderContextInfo.MultiResultElementInfo.Fields[el.Index];
            sb.Append($"public static readonly byte[] {fieldDefaultString}Bytes = new byte[] {{");
            foreach (var c in fieldDefaultString) {
                sb.Append($"{(byte)c},");
            }

            sb.Length--;
            sb.AppendLine("};");
        }

        sb.AppendLine("#endregion");

        sb.Indent--;
        sb.AppendLine("}");
    }

    void WriteGenericJsonConverter() {
        var typeParameters = context.TypeParameters();
        var typeParametersConstraints = context.TypeParametersConstraints(' ');
        var accessibility = context.MultiResult.Accessibility is TypeAccessibility.Public ? "public " : "";
        const string stj = "global::System.Text.Json";
        const string stjSer = "global::System.Text.Json.Serialization";
        sb.AppendInterpolatedLine(
            $$"""
            [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]
            {{accessibility}}sealed class JsonConverter_{{context.MultiResult.OnlyName}}{{typeParameters}} : {{stjSer}}.JsonConverter<{{context.MultiResult.GlobalName}}> {{typeParametersConstraints}}{
                public static readonly JsonConverter_{{context.MultiResult.OnlyName}}{{typeParameters}} Instance = new();
            """
        );
        sb.AppendInterpolatedLine(
            $"public override void Write({stj}.Utf8JsonWriter writer, {context.MultiResult.GlobalName} value, {stj}.JsonSerializerOptions options) {{"
        );
        sb.Indent++;
        sb.AppendLine("writer.WriteStartObject();");
        sb.Indent++;

        if (context.Configuration.OpenState is true) {
            sb.AppendLine("var state = (byte)value.State;");
        } else if (context.Configuration.AddIsProperties is true) {
            sb.Append("byte state = ");
            foreach (var el in context.Elements) {
                sb.AppendInterpolated($"value.{el.StateCheck.Property} ? (byte){el.Index + 1} : ");
            }

            sb.AppendLine("(byte)0;");
        }

        sb.AppendLine("switch(state) {");
        sb.Indent++;
        foreach (var el in context.Elements) {
            sb.AppendInterpolatedLine($"case {el.Index + 1}:");
            sb.Indent++;
            sb.AppendInterpolatedLine($"writer.WritePropertyName({MultiResultHolderContextInfo.MultiResultElementInfo.Fields[el.Index]}Bytes);");
            sb.AppendInterpolatedLine($"{stj}.JsonSerializer.Serialize(writer, value.{el.Property}, options);");
            sb.Indent--;
            sb.AppendLine("break;");
        }

        sb.AppendInterpolatedLine($"default: throw {Exceptions}.Default<{context.MultiResult.GlobalName}>();");
        sb.Indent--;
        sb.AppendLine("}");
        sb.AppendLine("writer.WriteEndObject();");
        //
        sb.Indent--;
        sb.AppendLine("}");
        sb.AppendInterpolatedLine(
            $"public override {context.MultiResult.GlobalName} Read(ref {stj}.Utf8JsonReader reader, global::System.Type typeToConvert, {stj}.JsonSerializerOptions options) {{"
        );
        sb.Indent++;
        sb.AppendInterpolatedLine(
            $$"""
            if (reader.TokenType != {{stj}}.JsonTokenType.StartObject) throw new {{stj}}.JsonException($"Expected '{({{stj}}.JsonTokenType.StartObject)}' but got '{reader.TokenType}'");
            reader.Read();
            var span = reader.ValueSpan;
            """
        );
        foreach (var el in context.Elements) {
            sb.AppendInterpolatedLine(
                $$"""
                if (span.SequenceEqual({{MultiResultHolderContextInfo.MultiResultElementInfo.Fields[el.Index]}}Bytes)) {
                    var value = {{stj}}.JsonSerializer.Deserialize<{{el.Type}}>(ref reader, options)!;
                    reader.Read();
                    return value;
                }
                """
            );
        }

        sb.AppendInterpolatedLine($$"""throw new {{stj}}.JsonException("Expected MultiResult ordinal field name property");""");

        sb.Indent--;
        sb.AppendLine("}");

        sb.AppendLine("#region Property names");

        foreach (var el in context.Elements) {
            var fieldDefaultString = MultiResultHolderContextInfo.MultiResultElementInfo.Fields[el.Index];
            sb.Append($"public static readonly byte[] {fieldDefaultString}Bytes = new byte[] {{");
            foreach (var c in fieldDefaultString) {
                sb.Append($"{(byte)c},");
            }

            sb.Length--;
            sb.AppendLine("};");
        }

        sb.AppendLine("#endregion");

        sb.Indent--;
        sb.AppendLine("}");
    }

    void WriteEndOfType() {
        sb.Indent--;
        bracesToCloseOnEnd--;
        sb.AppendLine("}");
    }

    void WriteEndOfFile() {
        for (var i = 0; i < bracesToCloseOnEnd; i++) {
            sb.Append('}');
        }

        sb.AppendLine();
    }
}
