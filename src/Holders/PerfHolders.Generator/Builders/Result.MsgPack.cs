namespace Perf.Holders.Generator.Builders;

using Internal;
using Types;

sealed class ResultMessagePackSourceBuilder(
    ResultHolderContextInfo context,
    CompInfo compInfo
) {
    const string Exceptions = "global::Perf.Holders.Exceptions.OptionHolderExceptions";
    readonly InterpolatedStringBuilder sb = new(stringBuilder: new());

    int bracesToCloseOnEnd;

    void Preparation() {
        if (compInfo.SupportNullableAnnotation() is false) {
            if (context.Ok.IsStruct is false) {
                context = context with {
                    Ok = context.Ok with {
                        TypeNullable = context.Ok.Type
                    }
                };
            }

            if (context.Error.IsStruct is false) {
                context = context with {
                    Error = context.Error with {
                        TypeNullable = context.Error.Type
                    }
                };
            }
        }
    }

    public string WriteAllAndBuild() {
        Preparation();
        DeclareTopLevelStatements();
        WriteMessagePackFormatter();
        // WriteEndOfType();
        WriteEndOfFile();
        return sb.ToString();
    }

    void DeclareTopLevelStatements() {
        sb.AppendLine("// <auto-generated />");
        if (compInfo.SupportNullableAnnotation()) {
            sb.AppendLine("#nullable enable");
        }

        if (compInfo.SupportFileScopedNamespace()) {
            sb.AppendLine("namespace Perf.Holders.Serialization.MessagePack;");
        } else {
            sb.AppendLine("namespace Perf.Holders.Serialization.MessagePack\n{");
            bracesToCloseOnEnd++;
        }
    }

    void WriteMessagePackFormatter() {
        var accessibility = context.Result.Accessibility is TypeAccessibility.Public ? "public " : "";
        const string msgPack = "global::MessagePack";
        sb.AppendInterpolatedLine(
            $$"""
            {{accessibility}}sealed class MessagePackFormatter_{{context.Result.OnlyName}} : {{msgPack}}.Formatters.IMessagePackFormatter<{{context.Result.GlobalName}}> {
                public static readonly MessagePackFormatter_{{context.Result.OnlyName}} Instance = new();
                
                public void Serialize(ref {{msgPack}}.MessagePackWriter writer, {{context.Result.GlobalName}} value, {{msgPack}}.MessagePackSerializerOptions options) {
                    var isOk = value.{{context.IsOk.Property}};
                    writer.WriteMapHeader(1);
                    if (isOk) {
                        writer.Write(1);
                        {{msgPack}}.MessagePackSerializer.Serialize(ref writer, value.{{context.Ok.Property}}, options);
                    } else {
                        writer.Write(2);
                        {{msgPack}}.MessagePackSerializer.Serialize(ref writer, value.{{context.Error.Property}}, options);
                    }
                }
                
                public {{context.Result.GlobalName}} Deserialize(ref {{msgPack}}.MessagePackReader reader, {{msgPack}}.MessagePackSerializerOptions options) {
                    if (reader.IsNil || reader.TryReadMapHeader(out var mapHeader)) {
                        throw new {{msgPack}}.MessagePackSerializationException($"Expected '{({{msgPack}}.MessagePackType.Map)}' but got '{reader.NextMessagePackType}'");
                    }
                    
                    if (mapHeader is not 1) {
                        throw new {{msgPack}}.MessagePackSerializationException($"Expected map header 1 but got '{mapHeader}'");
                    }
                    
                    var key = reader.ReadByte();
                    {{context.Result.GlobalName}} result = key switch {
                        1 => {{msgPack}}.MessagePackSerializer.Deserialize<{{context.Ok.Type}}>(ref reader, options),
                        2 => {{msgPack}}.MessagePackSerializer.Deserialize<{{context.Error.Type}}>(ref reader, options),
                        _ => throw new {{msgPack}}.MessagePackSerializationException($"Expected key 1 or 2 but got '{key}'")
                    };
                    
                    return result;
                }
            }
            """
        );
    }

    void WriteEndOfFile() {
        for (var i = 0; i < bracesToCloseOnEnd; i++) {
            sb.Indent--;
            sb.Append('}');
        }

        sb.AppendLine();
    }
}
