namespace Perf.Holders.Generator.Builders;

using System.Buffers;
using Internal;
using Types;

sealed class ResultSystemTextJsonSourceBuilder(ResultHolderContextInfo contextInfo) {
    readonly InterpolatedStringBuilder sb = new(stringBuilder: new(8000));

    readonly CompInfo compInfo = contextInfo.CompInfo;
    int bracesToCloseOnEnd;
    ResultHolderContextInfo context = contextInfo;

    void Preparation() {
        if (compInfo.SupportNullableAnnotation() is false) {
            if (context.Ok.IsStruct is false) {
                context = context with {
                    Ok = context.Ok with {
                        TypeNullable = context.Ok.Type
                    }
                };
            }

            if (context.Error.IsStruct is false) {
                context = context with {
                    Error = context.Error with {
                        TypeNullable = context.Error.Type
                    }
                };
            }
        }
    }

    public string WriteAllAndBuild() {
        Preparation();
        DeclareTopLevelStatements();
        if (context.Ok.IsTypeParameter || context.Error.IsTypeParameter) {
            WriteJsonConverterFactory();
        }

        WriteJsonConverter();
        WriteEndOfFile();
        return sb.ToString();
    }

    void DeclareTopLevelStatements() {
        sb.AppendLine("// <auto-generated />");
        if (compInfo.SupportNullableAnnotation()) {
            sb.AppendLine("#nullable enable");
        }

        if (compInfo.SupportFileScopedNamespace()) {
            sb.AppendLine("namespace Perf.Holders.Serialization.SystemTextJson;");
        } else {
            sb.AppendLine("namespace Perf.Holders.Serialization.SystemTextJson\n{");
            bracesToCloseOnEnd++;
        }
    }

    void WriteJsonConverterFactory() {
        var accessibility = context.GlobalAccessibility is TypeAccessibility.Public ? "public " : "";
        const string stj = "global::System.Text.Json";
        const string stjSer = "global::System.Text.Json.Serialization";
        var openTypeParameters = (context.Ok.IsTypeParameter, context.Error.IsTypeParameter) switch {
            (true, true)                   => "<,>",
            (true, false) or (false, true) => "<>",
            _                              => ""
        };

        var globalNameString = context.Result.GlobalName;
        var globalNameBuffer = ArrayPool<char>.Shared.Rent(globalNameString.Length);
        var globalName = globalNameBuffer.AsSpan(0, globalNameString.Length);
        globalNameString.AsSpan().CopyTo(globalName);
        var indexStart = globalName.LastIndexOf('<');
        openTypeParameters.AsSpan().CopyTo(globalName[indexStart..]);
        globalName = globalName[..(indexStart + openTypeParameters.Length)];


        sb.AppendInterpolatedLine(
            $$"""
            {{accessibility}}sealed class JsonConverterFactory_{{context.Result.OnlyName}} : {{stjSer}}.JsonConverterFactory
            {
                public static readonly JsonConverterFactory_{{context.Result.OnlyName}} Instance = new();

                public override bool CanConvert(Type typeToConvert) =>
                    cache.ContainsKey(typeToConvert) || (typeToConvert.IsConstructedGenericType && typeToConvert.GetGenericTypeDefinition() == typeof({{globalName}}));

                private readonly global::System.Collections.Concurrent.ConcurrentDictionary<Type, {{stjSer}}.JsonConverter> cache = new();

                public override {{stjSer}}.JsonConverter CreateConverter(Type typeToConvert, {{stj}}.JsonSerializerOptions options) =>
                    cache.GetOrAdd(
                        typeToConvert,
                        static t => {
                            var genericArguments = t.GetGenericArguments();
                            var t1 = genericArguments[0];
                            var t2 = genericArguments[1];
                            return ({{stjSer}}.JsonConverter)global::System.Activator.CreateInstance(typeof(JsonConverter_{{context.Result.OnlyName}}{{openTypeParameters}}).MakeGenericType(genericArguments))!;
                        }
                    ); 
            }
            """
        );

        ArrayPool<char>.Shared.Return(globalNameBuffer);
    }

    void WriteJsonConverter() {
        var accessibility = context.GlobalAccessibility is TypeAccessibility.Public ? "public " : "";
        const string stj = "global::System.Text.Json";
        const string stjSer = "global::System.Text.Json.Serialization";
        var typeParametersConstraints = (context.Ok.IsTypeParameter, context.Error.IsTypeParameter) switch {
            (true, true)  => $"    where {context.Ok.Type} : notnull where {context.Error.Type} : notnull ",
            (true, false) => $"    where {context.Ok.Type} : notnull ",
            (false, true) => $"    where {context.Error.Type} : notnull ",
            _             => ""
        };
        sb.AppendInterpolatedLine(
            $$"""
            {{accessibility}}sealed class JsonConverter_{{context.Result.DeclarationName}} : {{stjSer}}.JsonConverter<{{context.Result.GlobalName}}>
            {{typeParametersConstraints}}{
                public static readonly JsonConverter_{{context.Result.DeclarationName}} Instance = new();
                
                public override void Write({{stj}}.Utf8JsonWriter writer, {{context.Result.GlobalName}} value, {{stj}}.JsonSerializerOptions options)
                {
                    writer.WriteStartObject();
                    if (value.{{context.IsOk.Property}}) {
                        writer.WritePropertyName(okPropertyBytes);
                        {{stj}}.JsonSerializer.Serialize(writer, value.{{context.Ok.Property}}, options);
                    } else {
                        writer.WritePropertyName(errorPropertyBytes);
                        {{stj}}.JsonSerializer.Serialize(writer, value.{{context.Error.Property}}, options);
                    }
                    writer.WriteEndObject();
                }
                
                public override {{context.Result.GlobalName}} Read(ref {{stj}}.Utf8JsonReader reader, Type typeToConvert, {{stj}}.JsonSerializerOptions options)
                {
                    if (reader.TokenType != {{stj}}.JsonTokenType.StartObject) {
                        throw new {{stj}}.JsonException($"Expected '{({{stj}}.JsonTokenType.StartObject)}' but got '{reader.TokenType}'");
                    }
                    reader.Read();
                    var span = reader.ValueSpan;
                    if (span.SequenceEqual(okPropertyBytes)) {
                        var value = {{stj}}.JsonSerializer.Deserialize<{{context.Ok.Type}}>(ref reader, options)!;
                        reader.Read();
                        return value;
                    }
                    if (span.SequenceEqual(errorPropertyBytes)) {
                        var value = {{stj}}.JsonSerializer.Deserialize<{{context.Error.Type}}>(ref reader, options)!;
                        reader.Read();
                        return value;
                    }
                    throw new {{stj}}.JsonException($"Expected 'ok' or 'error' but got '{reader.GetString()}'");
                }
                
                static readonly byte[] okPropertyBytes = new byte[] { (byte)'o', (byte)'k' };
                static readonly byte[] errorPropertyBytes = new byte[] { (byte)'e', (byte)'r', (byte)'r', (byte)'o', (byte)'r' };
            }
            """
        );
    }

    void WriteEndOfFile() {
        for (var i = 0; i < bracesToCloseOnEnd; i++) {
            sb.Append('}');
        }

        sb.AppendLine();
    }
}
