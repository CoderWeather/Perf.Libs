// ReSharper disable All

namespace Perf.Holders.Generator;

using System.Diagnostics.CodeAnalysis;

[SuppressMessage("Performance", "CA1823:Avoid unused private fields")]
static class Patterns {
    const string Result = """
        // <auto-generated />
        {NullableFileAnnotation}
        {NamespaceDeclaration}
        {
        {DebugViewVisibility}sealed class {ResultName}_DebugView{TypeArguments} {TypeArgumentsConstraints}{
            public {ResultName}_DebugView({ResultShort} result) {
                this.State = ({ResultState})typeof({ResultShort})
                    .GetField("state", global::System.Reflection.BindingFlags.NonPublic | global::System.Reflection.BindingFlags.Instance)!
                    .GetValue(result)!;
                this.Value = this.State switch {
                    {ResultState}.Ok            => result.{OkProperty},
                    {ResultState}.Error         => result.{ErrorProperty},
                    {ResultState}.Uninitialized => "Uninitialized",
                    _ => "!!! Incorrect State !!!"
                };
            }

            public {ResultState} State { get; }
            public object? Value { get; }
        }

        [global::System.Diagnostics.DebuggerTypeProxy(typeof({ResultName}_DebugView{OpenTypeArguments}))]
        [global::System.Diagnostics.DebuggerDisplay("{DebugPrint()}")]
        [global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Auto)]
        readonly partial struct {ResultShort} :
            global::System.IEquatable<{ResultShort}>,
            global::System.IEquatable<{BaseResult}<{OkType}, {ErrorType}>>,
            global::System.IEquatable<{OkType}>,
            global::System.IEquatable<{BaseResult}.Ok<{OkType}>>
        {TypeArgumentsConstraints}{
            public {ResultName}() {
                state = {ResultState}.Uninitialized;
                {OkField} = default!;
                {ErrorField} = default!;
            }
            public {ResultName}({OkType} {OkField}) {
                state = {ResultState}.Ok;
                this.{OkField} = {OkField};
                {ErrorField} = default!;
            }
            public {ResultName}({ErrorType} {ErrorField}) {
                state = {ResultState}.Error;
                {OkField} = default!;
                this.{ErrorField} = {ErrorField};
            }
            public {ResultName}({BaseResult}.Ok<{OkType}> ok) : this({OkField}: ok.Value) { }
            public {ResultName}({BaseResult}.Error<{ErrorType}> error) : this({ErrorField}: error.Value) { }

            private readonly {ResultState} state;
            private readonly {OkType} {OkField};
            private readonly {ErrorType} {ErrorField};

        {OkInterfaceProperty}
            {DebuggerBrowsableNever}
            public {OkDeclarationModifiers}{OkType} {OkProperty} =>
                state switch {
                    {ResultState}.Ok            => {OkField},
                    {ResultState}.Error         => throw global::Perf.Holders.Exceptions.ResultHolderExceptions.ErrorAccessWhenOk<{ResultShort}, {OkType}, {ErrorType}>("{OkProperty}", "{ErrorProperty}"),
                    {ResultState}.Uninitialized => throw global::Perf.Holders.Exceptions.ResultHolderExceptions.Uninitialized<{ResultShort}, {OkType}, {ErrorType}>(),
                    _ => throw global::Perf.Holders.Exceptions.ResultHolderExceptions.StateOutOfValidValues<{ResultShort}, {OkType}, {ErrorType}>(state)
                };
        {ErrorInterfaceProperty}
            {DebuggerBrowsableNever}
            public {ErrorDeclarationModifiers}{ErrorType} {ErrorProperty} =>
                state switch {
                    {ResultState}.Ok            => throw global::Perf.Holders.Exceptions.ResultHolderExceptions.OkAccessWhenError<{ResultShort}, {OkType}, {ErrorType}>("{OkProperty}", "{ErrorProperty}"),
                    {ResultState}.Error         => {ErrorField},
                    {ResultState}.Uninitialized => throw global::Perf.Holders.Exceptions.ResultHolderExceptions.Uninitialized<{ResultShort}, {OkType}, {ErrorType}>(),
                    _ => throw global::Perf.Holders.Exceptions.ResultHolderExceptions.StateOutOfValidValues<{ResultShort}, {OkType}, {ErrorType}>(state)
                };
        {IsOkInterfaceProperty}
            {DebuggerBrowsableNever}
            public {IsOkDeclarationModifiers}bool {IsOkProperty} =>
                state switch {
                    {ResultState}.Ok            => true,
                    {ResultState}.Error         => false,
                    {ResultState}.Uninitialized => throw global::Perf.Holders.Exceptions.ResultHolderExceptions.Uninitialized<{ResultShort}, {OkType}, {ErrorType}>(),
                    _ => throw global::Perf.Holders.Exceptions.ResultHolderExceptions.StateOutOfValidValues<{ResultShort}, {OkType}, {ErrorType}>(state)
                };

        // Operators
            public static implicit operator {ResultShort}({OkType} {OkField}) => new({OkField}: {OkField});
            public static implicit operator {ResultShort}({BaseResult}.Ok<{OkType}> ok) => new({OkField}: ok.Value);
            public static implicit operator {ResultShort}({ErrorType} {ErrorField}) => new({ErrorField}: {ErrorField});
            public static implicit operator {ResultShort}({BaseResult}.Error<{ErrorType}> error) => new({ErrorField}: error.Value);
            public static implicit operator {BaseResult}<{OkType}, {ErrorType}>({ResultShort} r) => r.{IsOkProperty} ? new(ok: r.{OkField}) : new(error: r.{ErrorField});
            public static implicit operator {ResultShort}({BaseResult}<{OkType}, {ErrorType}> r) => r.IsOk ? new({OkField}: r.Ok) : new({ErrorField}: r.Error);
            public static implicit operator bool({ResultShort} holder) => holder.{IsOkProperty};
            public static bool operator ==({ResultShort} left, {ResultShort} right) => left.Equals(right);
            public static bool operator !=({ResultShort} left, {ResultShort} right) => left.Equals(right) is false;
            public static bool operator ==({ResultShort} left, {BaseResult}<{OkType}, {ErrorType}> right) => left.Equals(right);
            public static bool operator !=({ResultShort} left, {BaseResult}<{OkType}, {ErrorType}> right) => left.Equals(right) is false;
            public static bool operator ==({ResultShort} left, {OkType} right) => left.Equals(right);
            public static bool operator !=({ResultShort} left, {OkType} right) => left.Equals(right) is false;
            public static bool operator ==({ResultShort} left, {ErrorType} right) => left.Equals(right);
            public static bool operator !=({ResultShort} left, {ErrorType} right) => left.Equals(right) is false;

        // Casting
            public {BaseResult}<{OkType}, {ErrorType}> AsBase() => this;
            public TOther CastByRef<TOther>() where TOther : struct, global::Perf.Holders.IResultHolder<{OkType}, {ErrorType}> => global::Perf.Holders.___HoldersInvisibleHelpers.CastResult<{ResultShort}, {OkType}, {ErrorType}, TOther>(in this);

        // Equality
            public override bool Equals(object? obj) =>
                (obj is {ResultShort} other && Equals(other))
                    || (obj is {BaseResult}<{OkType}, {ErrorType}> result && Equals(result));
            public bool Equals({BaseResult}<{OkType}, {ErrorType}> other) => other.Equals(({BaseResult}<{OkType}, {ErrorType}>)this);
            public bool Equals({ResultShort} other) =>
                (state, other.state) switch {
                    ({ResultState}.Ok, {ResultState}.Ok)
                        => global::System.Collections.Generic.EqualityComparer<{OkType}>.Default.Equals({OkField}, other.{OkField}),
                    ({ResultState}.Error, {ResultState}.Error)
                        => global::System.Collections.Generic.EqualityComparer<{ErrorType}>.Default.Equals({ErrorField}, other.{ErrorField}),
                    ({ResultState}.Ok, {ResultState}.Error)
                        or ({ResultState}.Error, {ResultState}.Ok)
                        => false,
                    ({ResultState}.Uninitialized, {ResultState}.Uninitialized)
                        => throw global::Perf.Holders.Exceptions.ResultHolderExceptions.Uninitialized<{ResultShort}, {OkType}, {ErrorType}>(),
                    _   => throw global::Perf.Holders.Exceptions.ResultHolderExceptions.StateOutOfValidValues<{ResultShort}, {OkType}, {ErrorType}>(state)
                };
            public bool Equals({OkTypeForEquals} other) => {IsOkProperty} && global::System.Collections.Generic.EqualityComparer<{OkTypeForEquals}>.Default.Equals({OkField}, other);
            public bool Equals({BaseResult}.Ok<{OkType}> other) => {IsOkProperty} && global::System.Collections.Generic.EqualityComparer<{OkType}>.Default.Equals({OkField}, other.Value);
            public bool Equals({ErrorTypeForEquals} other) => {IsOkProperty} is false && global::System.Collections.Generic.EqualityComparer<{ErrorTypeForEquals}>.Default.Equals({ErrorField}, other);
            public bool Equals({BaseResult}.Error<{ErrorType}> other) => {IsOkProperty} is false && global::System.Collections.Generic.EqualityComparer<{ErrorType}>.Default.Equals({ErrorField}, other.Value);

            public override int GetHashCode() =>
                state switch {
                    {ResultState}.Ok            => {OkField}.GetHashCode(),
                    {ResultState}.Error         => {ErrorField}.GetHashCode(),
                    {ResultState}.Uninitialized => throw global::Perf.Holders.Exceptions.ResultHolderExceptions.Uninitialized<{ResultShort}, {OkType}, {ErrorType}>(),
                    _ => throw global::Perf.Holders.Exceptions.ResultHolderExceptions.StateOutOfValidValues<{ResultShort}, {OkType}, {ErrorType}>(state)
                };

            public override string? ToString() =>
                state switch {
                    {ResultState}.Ok            => {OkField}.ToString(),
                    {ResultState}.Error         => {ErrorField}.ToString(),
                    {ResultState}.Uninitialized => throw global::Perf.Holders.Exceptions.ResultHolderExceptions.Uninitialized<{ResultShort}, {OkType}, {ErrorType}>(),
                    _ => throw global::Perf.Holders.Exceptions.ResultHolderExceptions.StateOutOfValidValues<{ResultShort}, {OkType}, {ErrorType}>(state)
                };

            string DebugPrint() =>
                state switch {
                    {ResultState}.Ok            => $"{OkProperty}={{OkField}}",
                    {ResultState}.Error         => $"{ErrorProperty}={{ErrorField}}",
                    {ResultState}.Uninitialized => "Uninitialized",
                    _ => "!!! Incorrect State !!!"
                };

        // Map
            public {BaseResult}<TNewOk, {ErrorType}> Map<TNewOk>(Func<{OkType}, TNewOk> mapOk)
                where TNewOk : notnull
                => {IsOkProperty} ? mapOk({OkField}) : {ErrorField};
            public async global::System.Threading.Tasks.ValueTask<{BaseResult}<TNewOk, {ErrorType}>> Map<TNewOk>(Func<{OkType}, global::System.Threading.Tasks.ValueTask<TNewOk>> mapOk)
                where TNewOk : notnull
                => {IsOkProperty} ? await mapOk({OkField}) : {ErrorField};

            public {BaseResult}<{OkType}, TNewError> MapError<TNewError>(Func<{ErrorType}, TNewError> mapError)
                where TNewError : notnull
                => {IsOkProperty} ? {OkField} : mapError({ErrorField});
            public async global::System.Threading.Tasks.ValueTask<{BaseResult}<{OkType}, TNewError>> MapError<TNewError>(Func<{ErrorType}, global::System.Threading.Tasks.ValueTask<TNewError>> mapError)
                where TNewError : notnull
                => {IsOkProperty} ? {OkField} : await mapError({ErrorField});

            public {BaseResult}<TNewOk, TNewError> Map<TNewOk, TNewError>(
                Func<{OkType}, TNewOk> mapOk,
                Func<{ErrorType}, TNewError> mapError
            ) where TNewOk : notnull where TNewError : notnull =>
                {IsOkProperty} ? mapOk({OkField}) : mapError({ErrorField});
            public async global::System.Threading.Tasks.ValueTask<{BaseResult}<TNewOk, TNewError>> Map<TNewOk, TNewError>(
                Func<{OkType}, global::System.Threading.Tasks.ValueTask<TNewOk>> mapOk,
                Func<{ErrorType}, global::System.Threading.Tasks.ValueTask<TNewError>> mapError
            ) where TNewOk : notnull where TNewError : notnull =>
                {IsOkProperty} ? await mapOk({OkField}) : await mapError({ErrorField});
        }
        }
        """;

    const string Option = """
        // <auto-generated />
        {NullableFileAnnotation}
        {NamespaceDeclaration}
        {
        {DebugViewVisibility}sealed class {OptionName}_DebugView{TypeArguments} {TypeArgumentsConstraints}{
            public {OptionName}_DebugView({OptionShort} opt) {
                this.State = ({OptionState})typeof({OptionShort})
                    .GetField("state", global::System.Reflection.BindingFlags.NonPublic | global::System.Reflection.BindingFlags.Instance)!
                    .GetValue(opt)!;
                this.Value = this.State switch {
                    {OptionState}.Some => opt.{SomeProperty},
                    {OptionState}.None => "None",
                    _ => "!!! Incorrect State !!!"
                };
            }

            public {OptionState} State { get; }
            public object? Value { get; }
        }

        [global::System.Diagnostics.DebuggerTypeProxy(typeof({OptionName}_DebugView{OpenTypeArguments}))]
        [global::System.Diagnostics.DebuggerDisplay("{DebugPrint()}")]
        [global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Auto)]
        readonly partial struct {OptionShort} :
            global::System.IEquatable<{OptionShort}>,
            global::System.IEquatable<{BaseOption}<{SomeType}>>,
            global::System.IEquatable<{SomeType}>,
            global::System.IEquatable<{BaseOption}.Some<{SomeType}>> {
            public {OptionName}() {
                state = {OptionState}.None;
                {SomeField} = default!;
            }
            public {OptionName}({SomeTypeNullable} {SomeField}) {
                if({SomeField} != null) {
                    state = {OptionState}.Some;
                    this.{SomeField} = ({SomeType}){SomeField};
                } else {
                    state = {OptionState}.None;
                    this.{SomeField} = default!;
                }
            }
            public {OptionName}({BaseOption}.Some<{SomeType}> someObject) : this({SomeField}: someObject.Value) { }

            private readonly {OptionState} state;
            private readonly {SomeType} {SomeField};

        {SomeInterfaceProperty}
        {IsSomeInterfaceProperty}
            {DebuggerBrowsableNever}
            public {SomeDeclarationModifiers}{SomeType} {SomeProperty} =>
                state switch {
                    {OptionState}.Some => {SomeField},
                    {OptionState}.None => throw global::Perf.Holders.Exceptions.OptionHolderExceptions.SomeAccessWhenNone<{OptionShort}, {SomeType}>(),
                    _ => throw global::Perf.Holders.Exceptions.OptionHolderExceptions.StateOutOfValidValues<{OptionShort}, {SomeType}>(state)
                };
            {DebuggerBrowsableNever}
            public {IsSomeDeclarationModifiers}bool {IsSomeProperty} =>
                state switch {
                    {OptionState}.Some => true,
                    {OptionState}.None => false,
                    _ => throw global::Perf.Holders.Exceptions.OptionHolderExceptions.StateOutOfValidValues<{OptionShort}, {SomeType}>(state)
                };

        // Operators
            public static implicit operator {OptionShort}({SomeTypeNullable} {SomeField}) => new({SomeField}: {SomeField});
            public static implicit operator {OptionShort}({BaseOption}.Some<{SomeType}> some) => new({SomeField}: some.Value);
            public static implicit operator {OptionShort}({BaseOption}.None _) => default;
            public static implicit operator {BaseOption}<{SomeType}>({OptionShort} o) => o.{IsSomeProperty} ? new(o.{SomeProperty}) : default;
            public static implicit operator {OptionShort}({BaseOption}<{SomeType}> o) => o.IsSome ? new(o.Some) : default;
            public static implicit operator bool({OptionShort} option) => option.{IsSomeProperty};
            public static bool operator ==({OptionShort} left, {OptionShort} right) => left.Equals(right);
            public static bool operator !=({OptionShort} left, {OptionShort} right) => left.Equals(right) is false;
            public static bool operator ==({OptionShort} left, {BaseOption}<{SomeType}> right) => left.Equals(right);
            public static bool operator !=({OptionShort} left, {BaseOption}<{SomeType}> right) => left.Equals(right) is false;
            public static bool operator ==({OptionShort} left, {SomeType} right) => left.Equals(right);
            public static bool operator !=({OptionShort} left, {SomeType} right) => left.Equals(right) is false;
            public static bool operator ==({OptionShort} left, {BaseOption}.Some<{SomeType}> right) => left.Equals(right);
            public static bool operator !=({OptionShort} left, {BaseOption}.Some<{SomeType}> right) => left.Equals(right) is false;

        // Casting
            public {BaseOption}<{SomeType}> AsBase() => this;
            public TOther CastByRef<TOther>() where TOther : struct, global::Perf.Holders.IOptionHolder<{SomeType}> => global::Perf.Holders.___HoldersInvisibleHelpers.CastOption<{OptionShort}, {SomeType}, TOther>(in this);
        // Equality
            public override bool Equals(object? obj) =>
                obj switch {
                    null => false,
                    {OptionShort} o => Equals(o),
                    {BaseOption}<{SomeType}> b => Equals(b),
                    {SomeType} v => Equals(v),
                    {BaseOption}.Some<{SomeType}> s => Equals(s),
                    {BaseOption}.None => {IsSomeProperty} == false,
                    _ => false
                };
            public bool Equals({OptionShort} other) =>
                (state, other.state) switch {
                    ({OptionState}.Some, {OptionState}.Some) => global::System.Collections.Generic.EqualityComparer<{SomeType}>.Default.Equals({SomeField}, other.{SomeField}),
                    ({OptionState}.None, {OptionState}.None) => true,
                    _ => throw global::Perf.Holders.Exceptions.OptionHolderExceptions.StateOutOfValidValues<{OptionShort}, {SomeType}>(state)
                };
            public bool Equals({BaseOption}<{SomeType}> other) => other.Equals(({BaseOption}<{SomeType}>)this);
            public bool Equals({SomeTypeForEquals} v) => {IsSomeProperty} && global::System.Collections.Generic.EqualityComparer<{SomeTypeForEquals}>.Default.Equals({SomeField}, v);
            public bool Equals({BaseOption}.Some<{SomeType}> v) => {IsSomeProperty} && global::System.Collections.Generic.EqualityComparer<{SomeType}>.Default.Equals({SomeField}, v.Value);
            public override int GetHashCode() =>
                state switch {
                    {OptionState}.Some => {SomeField}.GetHashCode(),
                    {OptionState}.None => {BaseOption}.None.Value.GetHashCode(),
                    _ => throw global::Perf.Holders.Exceptions.OptionHolderExceptions.StateOutOfValidValues<{OptionShort}, {SomeType}>(state)
                };

            public override string? ToString() =>
                state switch {
                    {OptionState}.Some => {SomeField}.ToString(),
                    {OptionState}.None => {BaseOption}.None.Value.ToString(),
                    _ => throw global::Perf.Holders.Exceptions.OptionHolderExceptions.StateOutOfValidValues<{OptionShort}, {SomeType}>(state)
                };

            string DebugPrint() =>
                state switch {
                    {OptionState}.Some => $"{SomeProperty}={{SomeField}}",
                    {OptionState}.None => "None",
                    _ => "!!! Incorrect State !!!"
                };

        // Map
            public {BaseOption}<TNew> Map<TNew>(Func<{SomeType}, TNew> mapSome) where TNew : notnull =>
                    {IsSomeProperty} ? mapSome({SomeField}) : default({BaseOption}<TNew>);
            public async global::System.Threading.Tasks.ValueTask<{BaseOption}<TNew>> Map<TNew>(
                Func<{SomeType}, global::System.Threading.Tasks.ValueTask<TNew>> map
                ) where TNew : notnull => {IsSomeProperty} ? await map({SomeField}) : default({BaseOption}<TNew>);
        }
        }
        """;
}
