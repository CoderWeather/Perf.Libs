namespace Perf.Holders.Generator;

static class Patterns {
    public const string Result2 = """
        // <auto-generated />
        #nullable enable

        namespace {Namespace};

        {DebugViewVisibility}sealed class {ResultName}_DebugView{TypeArguments} {
            public {ResultName}_DebugView({ResultShort} result) {
                this.State = result.State;
                this.Value = State switch {
                    {ResultStateQualified}.Ok            => result.Ok,
                    {ResultStateQualified}.Error         => result.Error,
                    {ResultStateQualified}.Uninitialized => "Uninitialized",
                    _ => "!!!State is incorrent"
                };
            }
        
            public {ResultStateQualified} State { get; }
            public object? Value { get; }
        }

        [global::System.Diagnostics.DebuggerTypeProxy(typeof({ResultName}_DebugView{OpenTypeArguments}))]
        [global::System.Diagnostics.DebuggerDisplay("{DebugPrint()}")]
        [global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Auto)]
        readonly partial struct {ResultShort} :
            global::System.IEquatable<{ResultShort}>,
            global::System.IEquatable<global::Perf.Holders.Result<{OkQualified}, {ErrorQualified}>>,
            global::System.IEquatable<{OkQualified}>,
            global::System.IEquatable<global::Perf.Holders.Result.Ok<{OkQualified}>> {
            public {ResultName}() {
                state = {ResultStateQualified}.Uninitialized;
                ok = default!;
                error = default!;
            }
            public {ResultName}({OkQualified} ok) {
                state = {ResultStateQualified}.Ok;
                this.ok = ok;
                error = default!;
            }
            public {ResultName}({ErrorQualified} error) {
                state = {ResultStateQualified}.Error;
                ok = default!;
                this.error = error;
            }
            public {ResultName}(global::Perf.Holders.Result.Ok<{OkQualified}> ok) : this(ok: ok.Value) { }
            public {ResultName}(global::Perf.Holders.Result.Error<{ErrorQualified}> error) : this(error: error.Value) { }
        
            private readonly {ResultStateQualified} state;
            private readonly {OkQualified} ok;
            private readonly {ErrorQualified} error;
        
            private static readonly string UninitializedException = $"{ResultTypeofString} is Unitialized";
            private static readonly string ErrorAccessException =   $"Cannot access Error. {ResultTypeofString} is Ok";
            private static readonly string OkAccessException =      $"Cannot access Ok. {ResultTypeofString} is Error";
            
            [global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
            public {OkQualified} Ok =>
                state switch {
                    {ResultStateQualified}.Ok            => ok,
                    {ResultStateQualified}.Error         => throw new global::System.InvalidOperationException(ErrorAccessException),
                    {ResultStateQualified}.Uninitialized => throw new global::System.InvalidOperationException(UninitializedException),
                    _ => throw new global::System.ArgumentOutOfRangeException()
                };
            [global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
            public {ErrorQualified} Error =>
                state switch {
                    {ResultStateQualified}.Ok            => throw new global::System.InvalidOperationException(OkAccessException),
                    {ResultStateQualified}.Error         => error,
                    {ResultStateQualified}.Uninitialized => throw new global::System.InvalidOperationException(UninitializedException),
                    _ => throw new global::System.ArgumentOutOfRangeException()
                };
            [global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
            public bool IsOk =>
                state switch {
                    {ResultStateQualified}.Ok            => true,
                    {ResultStateQualified}.Error         => false,
                    {ResultStateQualified}.Uninitialized => throw new global::System.InvalidOperationException(UninitializedException),
                    _ => throw new global::System.ArgumentOutOfRangeException(nameof(state))
                };
            public {ResultStateQualified} State => state;
        // Operators
            public static implicit operator {ResultShort}({OkQualified} ok) => new(ok: ok);
            public static implicit operator {ResultShort}(global::Perf.Holders.Result.Ok<{OkQualified}> ok) => new(ok: ok.Value);
            public static implicit operator {ResultShort}({ErrorQualified} error) => new(error: error);
            public static implicit operator {ResultShort}(global::Perf.Holders.Result.Error<{ErrorQualified}> error) => new(error: error.Value);
            public static implicit operator global::Perf.Holders.Result<{OkQualified}, {ErrorQualified}>({ResultShort} m) => m.IsOk ? new(ok: m.ok) : new(error: m.error);
            public static implicit operator {ResultShort}(global::Perf.Holders.Result<{OkQualified}, {ErrorQualified}> r) => r.IsOk ? new(ok: r.Ok) : new(error: r.Error);
            public static implicit operator bool({ResultShort} holder) => holder.IsOk;
            public static bool operator ==({ResultShort} left, {ResultShort} right) => left.Equals(right);
            public static bool operator !=({ResultShort} left, {ResultShort} right) => left.Equals(right) is false;
            public static bool operator ==({ResultShort} left, global::Perf.Holders.Result<{OkQualified}, {ErrorQualified}> right) => left.Equals(right);
            public static bool operator !=({ResultShort} left, global::Perf.Holders.Result<{OkQualified}, {ErrorQualified}> right) => left.Equals(right) is false;
            public static bool operator ==({ResultShort} left, {OkQualified} right) => left.Equals(right);
            public static bool operator !=({ResultShort} left, {OkQualified} right) => left.Equals(right) is false;
            public static bool operator ==({ResultShort} left, {ErrorQualified} right) => left.Equals(right);
            public static bool operator !=({ResultShort} left, {ErrorQualified} right) => left.Equals(right) is false;
            
        // Casting
            public global::Perf.Holders.Result<{OkQualified}, {ErrorQualified}> AsBase() => this;
            public TOther As<TOther>() where TOther : struct, global::Perf.Holders.IResultHolder<{OkQualified}, {ErrorQualified}> {
                var t = this;
                return global::Perf.Holders.___HoldersInvisibleHelpers.Cast<{ResultShort}, {OkQualified}, {ErrorQualified}, TOther>(ref t);
            }

        // Equality
            public override bool Equals(object? obj) => 
                (obj is {ResultShort} other && Equals(other)) 
                    || (obj is global::Perf.Holders.Result<{OkQualified}, {ErrorQualified}> result && Equals(result));
            public bool Equals(global::Perf.Holders.Result<{OkQualified}, {ErrorQualified}> other) => other.Equals((global::Perf.Holders.Result<{OkQualified}, {ErrorQualified}>)this);
            public bool Equals({ResultShort} other) =>
                (state, other.state) switch {
                    ({ResultStateQualified}.Ok, {ResultStateQualified}.Ok)
                        => global::System.Collections.Generic.EqualityComparer<{OkQualified}>.Default.Equals(ok, other.ok),
                    ({ResultStateQualified}.Error, {ResultStateQualified}.Error)
                        => global::System.Collections.Generic.EqualityComparer<{ErrorQualified}>.Default.Equals(error, other.error),
                    ({ResultStateQualified}.Ok, {ResultStateQualified}.Error) 
                        or ({ResultStateQualified}.Error, {ResultStateQualified}.Ok)
                        => false,
                    ({ResultStateQualified}.Uninitialized, {ResultStateQualified}.Uninitialized) 
                        => true,
                    _   => throw new global::System.ArgumentOutOfRangeException(nameof(state))
                };
            public bool Equals({OkQualifiedForEquals} other) => IsOk && global::System.Collections.Generic.EqualityComparer<{OkQualifiedForEquals}>.Default.Equals(ok, other);
            public bool Equals(global::Perf.Holders.Result.Ok<{OkQualified}> other) => IsOk && global::System.Collections.Generic.EqualityComparer<{OkQualified}>.Default.Equals(ok, other.Value);
            public bool Equals({ErrorQualifiedForEquals} other) => IsOk is false && global::System.Collections.Generic.EqualityComparer<{ErrorQualifiedForEquals}>.Default.Equals(error, other);
            public bool Equals(global::Perf.Holders.Result.Error<{ErrorQualified}> other) => IsOk is false && global::System.Collections.Generic.EqualityComparer<{ErrorQualified}>.Default.Equals(error, other.Value);
            
            public override int GetHashCode() =>
                state switch {
                    {ResultStateQualified}.Ok            => ok.GetHashCode(),
                    {ResultStateQualified}.Error         => error.GetHashCode(),
                    {ResultStateQualified}.Uninitialized => throw new global::System.InvalidOperationException(UninitializedException),
                    _ => throw new global::System.ArgumentOutOfRangeException(nameof(state))
                };
            
            public override string? ToString() =>
                state switch {
                    {ResultStateQualified}.Ok            => ok.ToString(),
                    {ResultStateQualified}.Error         => error.ToString(), 
                    {ResultStateQualified}.Uninitialized => throw new global::System.InvalidOperationException(UninitializedException),
                    _ => throw new global::System.ArgumentOutOfRangeException(nameof(state))
                };
                
            public string DebugPrint() =>
                state switch {
                    {ResultStateQualified}.Ok            => $"Ok={ok}",
                    {ResultStateQualified}.Error         => $"Error={error}",
                    {ResultStateQualified}.Uninitialized => "Uninitialized",
                    _ => "!!!State is incorrent" 
                };

        // Map
            public global::Perf.Holders.Result<TNewOk, {ErrorQualified}> Map<TNewOk>(Func<{OkQualified}, TNewOk> mapOk)
                where TNewOk : notnull
                => IsOk ? mapOk(ok) : error;
            public async ValueTask<global::Perf.Holders.Result<TNewOk, {ErrorQualified}>> Map<TNewOk>(Func<{OkQualified}, global::System.Threading.Tasks.ValueTask<TNewOk>> mapOk)
                where TNewOk : notnull
                => IsOk ? await mapOk(ok) : error;
        
            public global::Perf.Holders.Result<{OkQualified}, TNewError> MapError<TNewError>(Func<{ErrorQualified}, TNewError> mapError)
                where TNewError : notnull
                => IsOk ? ok : mapError(error);
            public async ValueTask<global::Perf.Holders.Result<{OkQualified}, TNewError>> MapError<TNewError>(Func<{ErrorQualified}, global::System.Threading.Tasks.ValueTask<TNewError>> mapError)
                where TNewError : notnull
                => IsOk ? ok : await mapError(error);
        
            public global::Perf.Holders.Result<TNewOk, TNewError> Map<TNewOk, TNewError>(
                Func<{OkQualified}, TNewOk> mapOk,
                Func<{ErrorQualified}, TNewError> mapError
            ) where TNewOk : notnull where TNewError : notnull =>
                IsOk ? mapOk(ok) : mapError(error);
            public async ValueTask<global::Perf.Holders.Result<TNewOk, TNewError>> Map<TNewOk, TNewError>(
                Func<{OkQualified}, ValueTask<TNewOk>> mapOk,
                Func<{ErrorQualified}, ValueTask<TNewError>> mapError
            ) where TNewOk : notnull where TNewError : notnull =>
                IsOk ? await mapOk(ok) : await mapError(error);
        }
        """;

    public const string Option1 = """
        // <auto-generated />
        #nullable enable

        namespace {Namespace};

        {DebugViewVisibility}sealed class {OptionName}_DebugView{TypeArguments} {
            public {OptionName}_DebugView({OptionShort} opt) {
                this.State = opt.State;
                this.Value = State switch {
                    {OptionStateQualified}.Some => opt.Some,
                    {OptionStateQualified}.None => "None",
                    _ => "!!!State is incorrent"
                };
            }
        
            public {OptionStateQualified} State { get; }
            public object? Value { get; }
        }

        [global::System.Diagnostics.DebuggerTypeProxy(typeof({OptionName}_DebugView{OpenTypeArguments}))]
        [global::System.Diagnostics.DebuggerDisplay("{DebugPrint()}")]
        [global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Auto)]
        readonly partial struct {OptionShort} :
            global::System.IEquatable<{OptionShort}>,
            global::System.IEquatable<global::Perf.Holders.Option<{SomeQualified}>>,
            global::System.IEquatable<{SomeQualified}>,
            global::System.IEquatable<global::Perf.Holders.Option.Some<{SomeQualified}>> {
            public {OptionName}() {
                state = {OptionStateQualified}.None;
                some = default!;
            }
            public {OptionName}({SomeQualified} some) {
                state = {OptionStateQualified}.Some;
                this.some = some;
            }
            public {OptionName}(global::Perf.Holders.Option.Some<{SomeQualified}> some) : this(some: some.Value) { }
            
            private readonly {OptionStateQualified} state;
            private readonly {SomeQualified} some;
            
            private static readonly string NoneException = $"{OptionTypeofString} is None";
            
            [global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
            public {SomeQualified} Some =>
                state switch {
                    {OptionStateQualified}.Some => some,
                    {OptionStateQualified}.None => throw new global::System.InvalidOperationException(NoneException),
                    _ => throw new global::System.ArgumentOutOfRangeException()
                };
            [global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
            public bool IsSome =>
                state switch {
                    {OptionStateQualified}.Some => true,
                    {OptionStateQualified}.None => false,
                    _ => throw new global::System.ArgumentOutOfRangeException(nameof(state))
                };

            public {OptionStateQualified} State => state;
        // Operators
            public static implicit operator {OptionShort}({SomeQualified> some) => new(some);
            public static implicit operator {OptionShort}(global::Perf.Holders.Option.Some<{SomeQualified}> some) => new(some.Value);
            public static implicit operator {OptionShort}(global::Perf.Holders.Option.None _) => default;
            public static implicit operator bool({OptionShort} option) => option.IsSome;
            public static implicit operator global::Perf.Holders.Option<{SomeQualified}>({OptionShort} o) => o.IsSome ? new(o.Some) : default;
            public static implicit operator {OptionShort}(global::Perf.Holders.Option<{SomeQualified}> o) => o.IsSome ? new(o.Some) : default;
            public static bool operator ==({OptionShort} left, {OptionShort} right) => left.Equals(right);
            public static bool operator !=({OptionShort} left, {OptionShort} right) => left.Equals(right) is false;
            public static bool operator ==({OptionShort} left, global::Perf.Holders.Option<{SomeQualified}> right) => left.Equals(right);
            public static bool operator !=({OptionShort} left, global::Perf.Holders.Option<{SomeQualified}> right) => left.Equals(right) is false;
            public static bool operator ==({OptionShort} left, {SomeQualified} right) => left.Equals(right);
            public static bool operator !=({OptionShort} left, {SomeQualified} right) => left.Equals(right) is false;
            public static bool operator ==({OptionShort} left, global::Perf.Holders.Option.Some<{SomeQualified}> right) => left.Equals(right);
            public static bool operator !=({OptionShort} left, global::Perf.Holders.Option.Some<{SomeQualified}> right) => left.Equals(right) is false;

        // Equality
            public override bool Equals(object? obj) => 
                (obj is {OptionShort} other && Equals(other)) 
                    || (obj is global::Perf.Holders.Option<{SomeQualified}> o && Equals(o));
            public bool Equals({OptionShort} other) =>
                (state, other.state) switch {
                    ({OptionStateQualified}.Some, {OptionStateQualified}.Some) => global::System.Collections.Generic.EqualityComparer<{SomeQualified}>.Default.Equals(some, other.some),
                    ({OptionStateQualified}.None, {OptionStateQualified}.None) => true,
                    _ => throw new global::System.ArgumentOutOfRangeException(nameof(state))
                };
            public bool Equals(global::Perf.Holders.Option<{SomeQualified}> other) => other.Equals((global::Perf.Holders.Option<{SomeQualified}>)this);
            public bool Equals({SomeQualifiedForEquals} v) => IsSome && global::System.Collections.Generic.EqualityComparer<{SomeQualifiedForEquals}>.Default.Equals(some, v);
            public bool Equals(global::Perf.Holders.Option.Some<{SomeQualified}> v) => IsSome && global::System.Collections.Generic.EqualityComparer<{SomeQualified}>.Default.Equals(some, v.Value);
            public override int GetHashCode() =>
                state switch {
                    {OptionStateQualified}.Some => some.GetHashCode(),
                    {OptionStateQualified}.None => global::Perf.Holders.Option.None.Value.GetHashCode(),
                    _ => throw new global::System.ArgumentOutOfRangeException(nameof(state))
                };
            
            public override string? ToString() =>
                state switch {
                    {OptionStateQualified}.Some => some.ToString(),
                    {OptionStateQualified}.None => global::Perf.Holders.Option.None.Value.ToString(),
                    _ => throw new global::System.ArgumentOutOfRangeException(nameof(state))
                };
                
            public string DebugPrint() =>
                state switch {
                    {OptionStateQualified}.Some => $"Some={some}",
                    {OptionStateQualified}.None => "None",
                    _ => "!!!State is incorrent" 
                };

        // Map
            public global::Perf.Holders.Option<TNew> Map<TNew>(Func<{SomeQualified}, TNew> mapSome) where TNew : notnull =>
                    IsSome ? mapSome(Some) : default(global::Perf.Holders.Option<TNew>);
            public async global::System.Threading.Tasks.ValueTask<global::Perf.Holders.Option<TNew>> Map<TNew>(
                Func<{SomeQualified}, global::System.Threading.Tasks.ValueTask<TNew>> map
                ) where TNew : notnull => IsSome ? await map(some) : default(global::Perf.Holders.Option<TNew>);
        }
        """;
}
