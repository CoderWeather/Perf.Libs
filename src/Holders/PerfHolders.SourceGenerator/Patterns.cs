namespace Perf.Holders.Generator;

static class Patterns {
    public const string Result = """
        // <auto-generated />
        {NullableFileAnnotation}
        namespace {Namespace};

        {DebugViewVisibility}sealed class {ResultName}_DebugView{TypeArguments} {TypeArgumentsConstraints}{
            public {ResultName}_DebugView({ResultShort} result) {
                this.State = result.State;
                this.Value = State switch {
                    {ResultState}.Ok            => result.{OkProperty},
                    {ResultState}.Error         => result.{ErrorProperty},
                    {ResultState}.Uninitialized => "Uninitialized",
                    _ => "!!! Incorrect State !!!"
                };
            }

            public {ResultState} State { get; }
            public object? Value { get; }
        }

        [global::System.Diagnostics.DebuggerTypeProxy(typeof({ResultName}_DebugView{OpenTypeArguments}))]
        [global::System.Diagnostics.DebuggerDisplay("{DebugPrint()}")]
        [global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Auto)]
        readonly partial struct {ResultShort} :
            global::System.IEquatable<{ResultShort}>,
            global::System.IEquatable<{SharedResultQualified}<{OkType}, {ErrorType}>>,
            global::System.IEquatable<{OkType}>,
            global::System.IEquatable<{SharedResultQualified}.Ok<{OkType}>>
        {TypeArgumentsConstraints}{
            public {ResultName}() {
                state = {ResultState}.Uninitialized;
                {OkField} = default!;
                {ErrorField} = default!;
            }
            public {ResultName}({OkType} {OkField}) {
                state = {ResultState}.Ok;
                this.{OkField} = {OkField};
                {ErrorField} = default!;
            }
            public {ResultName}({ErrorType} {ErrorField}) {
                state = {ResultState}.Error;
                {OkField} = default!;
                this.{ErrorField} = {ErrorField};
            }
            public {ResultName}({SharedResultQualified}.Ok<{OkType}> {OkField}) : this({OkField}: {OkField}.Value) { }
            public {ResultName}({SharedResultQualified}.Error<{ErrorType}> {ErrorField}) : this({ErrorField}: {ErrorField}.Value) { }

            private readonly {ResultState} state;
            private readonly {OkType} {OkField};
            private readonly {ErrorType} {ErrorField};

            private static readonly string UninitializedException = $"{ResultTypeofString} is Unitialized";
            private static readonly string ErrorAccessException =   $"Cannot access {ErrorProperty}. {ResultTypeofString} is {OkProperty}";
            private static readonly string OkAccessException =      $"Cannot access {OkProperty}. {ResultTypeofString} is {ErrorProperty}";

            [global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
            public {OkDeclarationModifiers}{OkType} {OkProperty} =>
                state switch {
                    {ResultState}.Ok            => {OkField},
                    {ResultState}.Error         => throw new global::System.InvalidOperationException(ErrorAccessException),
                    {ResultState}.Uninitialized => throw new global::System.InvalidOperationException(UninitializedException),
                    _ => throw new global::System.ArgumentOutOfRangeException()
                };
            [global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
            public {ErrorDeclarationModifiers}{ErrorType} {ErrorProperty} =>
                state switch {
                    {ResultState}.Ok            => throw new global::System.InvalidOperationException(OkAccessException),
                    {ResultState}.Error         => {ErrorField},
                    {ResultState}.Uninitialized => throw new global::System.InvalidOperationException(UninitializedException),
                    _ => throw new global::System.ArgumentOutOfRangeException()
                };
            [global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
            public {IsOkDeclarationModifiers}bool {IsOkProperty} =>
                state switch {
                    {ResultState}.Ok            => true,
                    {ResultState}.Error         => false,
                    {ResultState}.Uninitialized => throw new global::System.InvalidOperationException(UninitializedException),
                    _ => throw new global::System.ArgumentOutOfRangeException(nameof(state))
                };
            public {ResultState} State => state;
        // Operators
            public static implicit operator {ResultShort}({OkType} {OkField}) => new({OkField}: {OkField});
            public static implicit operator {ResultShort}({SharedResultQualified}.Ok<{OkType}> {OkField}) => new({OkField}: {OkField}.Value);
            public static implicit operator {ResultShort}({ErrorType} {ErrorField}) => new({ErrorField}: {ErrorField});
            public static implicit operator {ResultShort}({SharedResultQualified}.Error<{ErrorType}> {ErrorField}) => new({ErrorField}: {ErrorField}.Value);
            public static implicit operator {SharedResultQualified}<{OkType}, {ErrorType}>({ResultShort} m) => m.{IsOkProperty} ? new(ok: m.{OkField}) : new(error: m.{ErrorField});
            public static implicit operator {ResultShort}({SharedResultQualified}<{OkType}, {ErrorType}> r) => r.IsOk ? new({OkField}: r.Ok) : new({ErrorField}: r.Error);
            public static implicit operator bool({ResultShort} holder) => holder.{IsOkProperty};
            public static bool operator ==({ResultShort} left, {ResultShort} right) => left.Equals(right);
            public static bool operator !=({ResultShort} left, {ResultShort} right) => left.Equals(right) is false;
            public static bool operator ==({ResultShort} left, {SharedResultQualified}<{OkType}, {ErrorType}> right) => left.Equals(right);
            public static bool operator !=({ResultShort} left, {SharedResultQualified}<{OkType}, {ErrorType}> right) => left.Equals(right) is false;
            public static bool operator ==({ResultShort} left, {OkType} right) => left.Equals(right);
            public static bool operator !=({ResultShort} left, {OkType} right) => left.Equals(right) is false;
            public static bool operator ==({ResultShort} left, {ErrorType} right) => left.Equals(right);
            public static bool operator !=({ResultShort} left, {ErrorType} right) => left.Equals(right) is false;

        // Casting
            public {SharedResultQualified}<{OkType}, {ErrorType}> AsBase() => this;
            public TOther As<TOther>() where TOther : struct, global::Perf.Holders.IResultHolder<{OkType}, {ErrorType}> {
                var t = this;
                return global::Perf.Holders.___HoldersInvisibleHelpers.Cast<{ResultShort}, {OkType}, {ErrorType}, TOther>(ref t);
            }

        // Equality
            public override bool Equals(object? obj) =>
                (obj is {ResultShort} other && Equals(other))
                    || (obj is {SharedResultQualified}<{OkType}, {ErrorType}> result && Equals(result));
            public bool Equals({SharedResultQualified}<{OkType}, {ErrorType}> other) => other.Equals(({SharedResultQualified}<{OkType}, {ErrorType}>)this);
            public bool Equals({ResultShort} other) =>
                (state, other.state) switch {
                    ({ResultState}.Ok, {ResultState}.Ok)
                        => global::System.Collections.Generic.EqualityComparer<{OkType}>.Default.Equals({OkField}, other.{OkField}),
                    ({ResultState}.Error, {ResultState}.Error)
                        => global::System.Collections.Generic.EqualityComparer<{ErrorType}>.Default.Equals({ErrorField}, other.{ErrorField}),
                    ({ResultState}.Ok, {ResultState}.Error)
                        or ({ResultState}.Error, {ResultState}.Ok)
                        => false,
                    ({ResultState}.Uninitialized, {ResultState}.Uninitialized)
                        => true,
                    _   => throw new global::System.ArgumentOutOfRangeException(nameof(state))
                };
            public bool Equals({OkTypeForEquals} other) => {IsOkProperty} && global::System.Collections.Generic.EqualityComparer<{OkTypeForEquals}>.Default.Equals({OkField}, other);
            public bool Equals({SharedResultQualified}.Ok<{OkType}> other) => {IsOkProperty} && global::System.Collections.Generic.EqualityComparer<{OkType}>.Default.Equals({OkField}, other.Value);
            public bool Equals({ErrorTypeForEquals} other) => {IsOkProperty} is false && global::System.Collections.Generic.EqualityComparer<{ErrorTypeForEquals}>.Default.Equals({ErrorField}, other);
            public bool Equals({SharedResultQualified}.Error<{ErrorType}> other) => {IsOkProperty} is false && global::System.Collections.Generic.EqualityComparer<{ErrorType}>.Default.Equals({ErrorField}, other.Value);

            public override int GetHashCode() =>
                state switch {
                    {ResultState}.Ok            => {OkField}.GetHashCode(),
                    {ResultState}.Error         => {ErrorField}.GetHashCode(),
                    {ResultState}.Uninitialized => throw new global::System.InvalidOperationException(UninitializedException),
                    _ => throw new global::System.ArgumentOutOfRangeException(nameof(state))
                };

            public override string? ToString() =>
                state switch {
                    {ResultState}.Ok            => {OkField}.ToString(),
                    {ResultState}.Error         => {ErrorField}.ToString(),
                    {ResultState}.Uninitialized => throw new global::System.InvalidOperationException(UninitializedException),
                    _ => throw new global::System.ArgumentOutOfRangeException(nameof(state))
                };

            public string DebugPrint() =>
                state switch {
                    {ResultState}.Ok            => $"{OkProperty}={{OkField}}",
                    {ResultState}.Error         => $"{ErrorProperty}={{ErrorField}}",
                    {ResultState}.Uninitialized => "Uninitialized",
                    _ => "!!! Incorrect State !!!"
                };

        // Map
            public {SharedResultQualified}<TNewOk, {ErrorType}> Map<TNewOk>(Func<{OkType}, TNewOk> mapOk)
                where TNewOk : notnull
                => {IsOkProperty} ? mapOk({OkField}) : {ErrorField};
            public async ValueTask<{SharedResultQualified}<TNewOk, {ErrorType}>> Map<TNewOk>(Func<{OkType}, global::System.Threading.Tasks.ValueTask<TNewOk>> mapOk)
                where TNewOk : notnull
                => {IsOkProperty} ? await mapOk({OkField}) : {ErrorField};

            public {SharedResultQualified}<{OkType}, TNewError> MapError<TNewError>(Func<{ErrorType}, TNewError> mapError)
                where TNewError : notnull
                => {IsOkProperty} ? {OkField} : mapError({ErrorField});
            public async ValueTask<{SharedResultQualified}<{OkType}, TNewError>> MapError<TNewError>(Func<{ErrorType}, global::System.Threading.Tasks.ValueTask<TNewError>> mapError)
                where TNewError : notnull
                => {IsOkProperty} ? {OkField} : await mapError({ErrorField});

            public {SharedResultQualified}<TNewOk, TNewError> Map<TNewOk, TNewError>(
                Func<{OkType}, TNewOk> mapOk,
                Func<{ErrorType}, TNewError> mapError
            ) where TNewOk : notnull where TNewError : notnull =>
                {IsOkProperty} ? mapOk({OkField}) : mapError({ErrorField});
            public async ValueTask<{SharedResultQualified}<TNewOk, TNewError>> Map<TNewOk, TNewError>(
                Func<{OkType}, ValueTask<TNewOk>> mapOk,
                Func<{ErrorType}, ValueTask<TNewError>> mapError
            ) where TNewOk : notnull where TNewError : notnull =>
                {IsOkProperty} ? await mapOk({OkField}) : await mapError({ErrorField});
        }
        """;

    public const string Option = """
        // <auto-generated />
        #nullable enable

        namespace {Namespace};

        {DebugViewVisibility}sealed class {OptionName}_DebugView{TypeArguments} {
            public {OptionName}_DebugView({OptionShort} opt) {
                this.State = opt.State;
                this.Value = State switch {
                    {OptionStateQualified}.Some => opt.Some,
                    {OptionStateQualified}.None => "None",
                    _ => "!!! Incorrect State !!!"
                };
            }

            public {OptionStateQualified} State { get; }
            public object? Value { get; }
        }

        [global::System.Diagnostics.DebuggerTypeProxy(typeof({OptionName}_DebugView{OpenTypeArguments}))]
        [global::System.Diagnostics.DebuggerDisplay("{DebugPrint()}")]
        [global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Auto)]
        readonly partial struct {OptionShort} :
            global::System.IEquatable<{OptionShort}>,
            global::System.IEquatable<global::Perf.Holders.Option<{SomeQualified}>>,
            global::System.IEquatable<{SomeQualified}>,
            global::System.IEquatable<global::Perf.Holders.Option.Some<{SomeQualified}>> {
            public {OptionName}() {
                state = {OptionStateQualified}.None;
                some = default!;
            }
            public {OptionName}({SomeQualified} some) {
                state = {OptionStateQualified}.Some;
                this.some = some;
            }
            public {OptionName}(global::Perf.Holders.Option.Some<{SomeQualified}> some) : this(some: some.Value) { }

            private readonly {OptionStateQualified} state;
            private readonly {SomeQualified} some;

            private static readonly string NoneException = $"{OptionTypeofString} is None";

            [global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
            public {SomeQualified} Some =>
                state switch {
                    {OptionStateQualified}.Some => some,
                    {OptionStateQualified}.None => throw new global::System.InvalidOperationException(NoneException),
                    _ => throw new global::System.ArgumentOutOfRangeException()
                };
            [global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]
            public bool IsSome =>
                state switch {
                    {OptionStateQualified}.Some => true,
                    {OptionStateQualified}.None => false,
                    _ => throw new global::System.ArgumentOutOfRangeException(nameof(state))
                };

            public {OptionStateQualified} State => state;
        // Operators
            public static implicit operator {OptionShort}({SomeQualified} some) => new(some);
            public static implicit operator {OptionShort}(global::Perf.Holders.Option.Some<{SomeQualified}> some) => new(some.Value);
            public static implicit operator {OptionShort}(global::Perf.Holders.Option.None _) => default;
            public static implicit operator bool({OptionShort} option) => option.IsSome;
            public static implicit operator global::Perf.Holders.Option<{SomeQualified}>({OptionShort} o) => o.IsSome ? new(o.Some) : default;
            public static implicit operator {OptionShort}(global::Perf.Holders.Option<{SomeQualified}> o) => o.IsSome ? new(o.Some) : default;
            public static bool operator ==({OptionShort} left, {OptionShort} right) => left.Equals(right);
            public static bool operator !=({OptionShort} left, {OptionShort} right) => left.Equals(right) is false;
            public static bool operator ==({OptionShort} left, global::Perf.Holders.Option<{SomeQualified}> right) => left.Equals(right);
            public static bool operator !=({OptionShort} left, global::Perf.Holders.Option<{SomeQualified}> right) => left.Equals(right) is false;
            public static bool operator ==({OptionShort} left, {SomeQualified} right) => left.Equals(right);
            public static bool operator !=({OptionShort} left, {SomeQualified} right) => left.Equals(right) is false;
            public static bool operator ==({OptionShort} left, global::Perf.Holders.Option.Some<{SomeQualified}> right) => left.Equals(right);
            public static bool operator !=({OptionShort} left, global::Perf.Holders.Option.Some<{SomeQualified}> right) => left.Equals(right) is false;

        // Equality
            public override bool Equals(object? obj) =>
                (obj is {OptionShort} other && Equals(other))
                    || (obj is global::Perf.Holders.Option<{SomeQualified}> o && Equals(o));
            public bool Equals({OptionShort} other) =>
                (state, other.state) switch {
                    ({OptionStateQualified}.Some, {OptionStateQualified}.Some) => global::System.Collections.Generic.EqualityComparer<{SomeQualified}>.Default.Equals(some, other.some),
                    ({OptionStateQualified}.None, {OptionStateQualified}.None) => true,
                    _ => throw new global::System.ArgumentOutOfRangeException(nameof(state))
                };
            public bool Equals(global::Perf.Holders.Option<{SomeQualified}> other) => other.Equals((global::Perf.Holders.Option<{SomeQualified}>)this);
            public bool Equals({SomeQualifiedForEquals} v) => IsSome && global::System.Collections.Generic.EqualityComparer<{SomeQualifiedForEquals}>.Default.Equals(some, v);
            public bool Equals(global::Perf.Holders.Option.Some<{SomeQualified}> v) => IsSome && global::System.Collections.Generic.EqualityComparer<{SomeQualified}>.Default.Equals(some, v.Value);
            public override int GetHashCode() =>
                state switch {
                    {OptionStateQualified}.Some => some.GetHashCode(),
                    {OptionStateQualified}.None => global::Perf.Holders.Option.None.Value.GetHashCode(),
                    _ => throw new global::System.ArgumentOutOfRangeException(nameof(state))
                };

            public override string? ToString() =>
                state switch {
                    {OptionStateQualified}.Some => some.ToString(),
                    {OptionStateQualified}.None => global::Perf.Holders.Option.None.Value.ToString(),
                    _ => throw new global::System.ArgumentOutOfRangeException(nameof(state))
                };

            public string DebugPrint() =>
                state switch {
                    {OptionStateQualified}.Some => $"Some={some}",
                    {OptionStateQualified}.None => "None",
                    _ => "!!! Incorrect State !!!"
                };

        // Map
            public global::Perf.Holders.Option<TNew> Map<TNew>(Func<{SomeQualified}, TNew> mapSome) where TNew : notnull =>
                    IsSome ? mapSome(Some) : default(global::Perf.Holders.Option<TNew>);
            public async global::System.Threading.Tasks.ValueTask<global::Perf.Holders.Option<TNew>> Map<TNew>(
                Func<{SomeQualified}, global::System.Threading.Tasks.ValueTask<TNew>> map
                ) where TNew : notnull => IsSome ? await map(some) : default(global::Perf.Holders.Option<TNew>);
        }
        """;
}
