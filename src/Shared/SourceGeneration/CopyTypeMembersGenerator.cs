namespace Perf.SourceGeneration;

[Generator]
public sealed class CopyTypeMembersGenerator : IIncrementalGenerator {
    private const string CopyTypeMembersAttributeFullName = "Perf.Utilities.SourceGeneration.CopyTypeMembersAttribute";
    private const string IgnoreMembersAttributeFullName = "Perf.Utilities.SourceGeneration.IgnoreMembersAttribute";
    private const string IncludeMembersAttributeFullName = "Perf.Utilities.SourceGeneration.IncludeMembersAttribute";

    private const string MessagePackObjectAttributeFullName = "MessagePack.MessagePackObjectAttribute";
    private const string MessagePackKeyAttributeFullName = "MessagePack.KeyAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        var types = context.SyntaxProvider.CreateSyntaxProvider(
            static (node, ct) => {
                if (node is TypeDeclarationSyntax {
                        AttributeLists.Count: > 0
                    } t) {
                    if (t.Modifiers.Any(SyntaxKind.PartialKeyword)) {
                        foreach (var al in t.AttributeLists) {
                            foreach (var a in al.Attributes) {
                                if (a.Name.ToString() is "CopyTypeMembers" or "CopyTypeMembersAttribute") {
                                    return true;
                                }
                            }
                        }
                    }
                }

                return false;
            },
            static (context, ct) => {
                var syntax = (TypeDeclarationSyntax)context.Node;
                if (context.SemanticModel.GetDeclaredSymbol(syntax, ct) is not { } symbol) {
                    return default;
                }

                foreach (var a in symbol.GetAttributes()) {
                    if (a.AttributeClass?.FullPath() is CopyTypeMembersAttributeFullName) {
                        return symbol;
                    }
                }

                return default;
            }
        );
        var filtered = types.Where(x => x != default).Select((x, _) => x!);

        context.RegisterSourceOutput(filtered.Collect().Combine(context.CompilationProvider),
            static (context, tuple) => {
                var (types, compilation) = tuple;
                if (types.IsDefaultOrEmpty) {
                    return;
                }

                var ct = context.CancellationToken;

                foreach (var group in types.GroupBy(x => x.ContainingNamespace.ToDisplayString())) {
                    ct.ThrowIfCancellationRequested();
                    var ns = group.Key!;

                    using var writer = new IndentedTextWriter(new StringWriter(), "	");
                    writer.WriteLines("// <auto-generated />", null, "#nullable enable");
                    writer.WriteLine($"namespace {ns} {{");
                    writer.Indent++;

                    foreach (var type in group) {
                        var marker = type.GetAttribute(CopyTypeMembersAttributeFullName);
                        var setMessagePackKeys = false;
                        if (type.TryGetAttribute(MessagePackObjectAttributeFullName) is { } msgPackObj) {
                            if (msgPackObj.ConstructorArguments.Length is 0 || msgPackObj.ConstructorArguments[0].As<bool>() is false) {
                                setMessagePackKeys = true;
                            } else if (msgPackObj.ConstructorArguments[0].As<bool>()) {
                                setMessagePackKeys = false;
                            }
                        }

                        var ignoreMembers = type.GetAttributes(IgnoreMembersAttributeFullName)
                           .SelectMany(x => x?.ConstructorArguments[0].Values.Select(y => y.Value as string))
                           .ToArray();
                        var includeMembers = type.GetAttributes(IncludeMembersAttributeFullName)
                           .SelectMany(x => x?.ConstructorArguments[0].Values.Select(y => y.Value as string))
                           .ToArray();

                        var originType = marker.ConstructorArguments[0].As<INamedTypeSymbol>()!;

                        var typeProperties = type.GetMembers()
                           .OfType<IPropertySymbol>()
                           .Where(p => p is {
                                IsStatic: false,
                                IsIndexer: false,
                                DeclaredAccessibility: Accessibility.Public
                            })
                           .ToArray();
                        var typePropertyNames = typeProperties.Select(x => x.Name).ToArray();
                        var originProperties = originType.GetMembers()
                           .OfType<IPropertySymbol>()
                           .Where(x => typePropertyNames.Contains(x.Name) is false)
                           .Where(p => p is {
                                IsStatic: false,
                                IsIndexer: false,
                                DeclaredAccessibility: Accessibility.Public
                            });
                        if (ignoreMembers.Any()) {
                            originProperties = originProperties.Where(p => ignoreMembers.Contains(p.Name) is false);
                        }

                        if (includeMembers.Any()) {
                            originProperties = originProperties.Where(p => includeMembers.Contains(p.Name));
                        }

                        var i = 0;

                        if (setMessagePackKeys) {
                            var withKeyAttr = typeProperties.Where(x => x.HasAttribute(MessagePackKeyAttributeFullName)).ToArray();
                            if (withKeyAttr.Any()) {
                                var maxIndex = withKeyAttr
                                   .Select(x => x.GetAttribute(MessagePackKeyAttributeFullName).ConstructorArguments[0].As<int>())
                                   .Max();
                                i = maxIndex + 1;
                            }
                        }

                        writer.WriteLine($"partial {type.DeclarationString()} {type.MinimalName()} {{");
                        writer.Indent++;
                        foreach (var p in originProperties) {
                            if (setMessagePackKeys) {
                                writer.WriteLine($"[global::MessagePack.Key({i})]");
                            }

                            var defaultString = p.Type.IsReferenceType ? "null!" : "default";
                            writer.WriteLine($"public {p.Type.GlobalName()} {p.Name} {{ get; set; }} = {defaultString};");
                            i++;
                        }

                        writer.Indent--;
                        writer.WriteLine("}");
                    }

                    writer.Indent--;
                    writer.WriteLine("}");

                    ct.ThrowIfCancellationRequested();
                    var sourceCode = writer.InnerWriter.ToString()!;
                    context.AddSource($"{GetShortNamespaceName(compilation, ns)}.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
                }
            }
        );
    }

    private static string GetShortNamespaceName(Compilation compilation, string ns) {
        var shorted = ns.Replace($"{compilation.Assembly.Name}.", null);
        return shorted.Length > 0 ? shorted : "Generated";
    }
}