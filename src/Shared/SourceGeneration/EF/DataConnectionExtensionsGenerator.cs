namespace Perf.SourceGeneration.EF;

[Generator]
internal sealed class DataConnectionExtensionsGenerator : IIncrementalGenerator {
	private sealed record ContextPack(INamedTypeSymbol Symbol) {
		public readonly List<(INamedTypeSymbol Type, string Name, bool HasDtoRepresentation)> Tables = new();
	}

	public void Initialize(IncrementalGeneratorInitializationContext context) {
		var types = context.SyntaxProvider
		   .CreateSyntaxProvider(SyntaxFilter, SyntaxTransform)
		   .Where(x => x is not null)
		   .Select((nts, ct) => nts!)
		   .Collect();

		context.RegisterSourceOutput(types, CodeGeneration);
	}

	private static bool SyntaxFilter(SyntaxNode node, CancellationToken ct) {
		if (node is ClassDeclarationSyntax cls) {
			var isBaseTypeDbContext = Enumerable.Any<BaseTypeSyntax>(
				cls.BaseList?.Types,
				x => x.ToString() is "DbContext" or "IdentityContext" || x.ToString().StartsWith("IdentityContext")
			) is true;
			var isAbstract = cls.Modifiers.Any(SyntaxKind.AbstractKeyword);

			return isBaseTypeDbContext && isAbstract is false;
		}

		return false;
	}

	private static ContextPack? SyntaxTransform(GeneratorSyntaxContext context, CancellationToken ct) {
		var contextType = context.TryGetType("Microsoft.EntityFrameworkCore.DbContext");
		var dataConnectionType = context.TryGetType("LinqToDB.Data.DataConnection");
		var dbSetType = context.TryGetType("Microsoft.EntityFrameworkCore.DbSet`1")!;

		if (contextType is null || dataConnectionType is null) {
			return null;
		}

		var symbol = context.Node switch {
			ClassDeclarationSyntax cls => context.SemanticModel.GetDeclaredSymbol(cls),
			_                          => null
		};
		if (symbol is null) {
			return null;
		}

		if (symbol.GetAllAncestors()
			   .Any(x => x.OriginalDefinition.StrictEquals(contextType)) is false) {
			return null;
		}

		var properties = symbol.GetMembers()
		   .OfType<IPropertySymbol>()
		   .Where(x => x.Type.OriginalDefinition.StrictEquals(dbSetType))
		   .ToArray();

		if (properties.Length is 0) {
			return null;
		}

		var pack = new ContextPack(symbol);
		foreach (var set in properties) {
			if (set.Type is not INamedTypeSymbol nt) {
				continue;
			}

			var table = nt.TypeArguments[0];
			if (table is not INamedTypeSymbol tableSymbol) {
				continue;
			}

			var hasDtoRepresentation = table.OriginalDefinition.GetAttributes()
			   .Any(x => x.AttributeClass?.Name is "RecordAsDtoAttribute");

			pack.Tables.Add((tableSymbol.OriginalDefinition, set.Name, hasDtoRepresentation));
		}

		return pack;
	}

	private static void CodeGeneration(SourceProductionContext context, ImmutableArray<ContextPack> types) {
		if (types.IsDefaultOrEmpty) {
			return;
		}

		foreach (var type in types) {
			context.CancellationToken.ThrowIfCancellationRequested();
			var sourceCode = GenerateSourceCode(type);
			if (sourceCode is null) {
				continue;
			}

			context.CancellationToken.ThrowIfCancellationRequested();
			context.AddSource($"{type.Symbol.Name}.g.cs", SourceText.From(sourceCode, Encoding.UTF8));
		}
	}

	private static string? GenerateSourceCode(ContextPack type) {
		using var writer = new IndentedTextWriter(new StringWriter(), "	");

		writer.WriteLines(
			"// <auto-generated />",
			"#pragma warning disable CS8019",
			"#pragma warning disable CS0105",
			"#nullable enable",
			null,
			$"namespace {type.Symbol.ContainingNamespace};",
			null,
			"using LinqToDB;",
			"using LinqToDB.Data;",
			null
		);

		var nsFromTables = type
		   .Tables.SelectMany(
				x => x.HasDtoRepresentation
					? new[] {
						x.Type.ContainingNamespace.ToDisplayString(),
						$"{x.Type.ContainingNamespace}.Dto"
					}
					: new[] { x.Type.ContainingNamespace.ToDisplayString() }
			)
		   .Distinct()
		   .ToArray();

		foreach (var n in nsFromTables) {
			writer.WriteLine($"using {n};");
		}

		writer.WriteLine();

		var accessibility = type.Symbol.Accessibility();
		writer.WriteLine($"{accessibility} static class {type.Symbol.Name}_Tables_DataConnectionExtensions");
		using (NestedScope.Start(writer)) {
			foreach (var t in type.Tables) {
				writer.WriteLine(
					$"public static ITable<{t.Type.Name}> {t.Name}(this DataConnection connection) => connection.GetTable<{t.Type.Name}>();"
				);
				if (t.HasDtoRepresentation) {
					writer.WriteLine(
						$"public static ITable<{t.Type.Name}Dto> {t.Name}Dto(this DataConnection connection) => connection.GetTable<{t.Type.Name}Dto>();"
					);
				}
			}
		}

		return writer.InnerWriter.ToString();
	}
}
